package client

var (
	Template = `// Code generated by httptest; DO NOT EDIT.
// github.com/protogodev/httptest

package {{$.DstPkgName}}_test

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"reflect"
	"strings"
	"testing"
	"time"

	{{- range $.Data.Imports}}
	{{.ImportString}}
	{{- end}}

	{{- range $.Spec.Imports}}
	{{.ImportString}}
	{{- end}}
)

{{- $srcPkgPrefix := $.Data.SrcPkgQualifier}}
{{- $interfaceName := $.Data.InterfaceName}}
{{- $mockInterfaceName := printf "%sClientMock" $interfaceName}}

{{- if $.Spec.Codec}}
var clientCodec = {{$.Spec.Codec}}
{{- else}}
var clientCodec = structool.New().TagName("httptest").
	DecodeHook(
		structool.DecodeStringToError,
		structool.DecodeStringToTime(time.RFC3339),
		structool.DecodeStringToDuration,
	).
	EncodeHook(
		structool.EncodeErrorToString,
		structool.EncodeTimeToString(time.RFC3339),
		structool.EncodeDurationToString,
	)
{{- end}} {{/* if $.Spec.Codec */}}

type RoundTripFunc func(req *http.Request) (*http.Response, error)

func (f RoundTripFunc) RoundTrip(req *http.Request) (*http.Response, error) {
        return f(req)
}

// NewTestClient creates a new *http.Client with Transport mocked.
func NewTestHTTPClient(fn RoundTripFunc) *http.Client {
        return &http.Client{Transport: fn}
}

type ClientRequest struct {
	Method string
	Path   string
	Header http.Header
	Body   []byte
}

func (want ClientRequest) Equal(req *http.Request) error {
	if req.Method != want.Method {
		return fmt.Errorf("Method: got (%s), want (%s)", req.Method, want.Method)
	}
	if req.URL.Path != want.Path {
		return fmt.Errorf("Path: got (%s), want (%s)", req.URL.Path, want.Path)
	}

	var gotHeader http.Header
	if len(want.Header) > 0 {
		gotHeader = http.Header{}
	}
	for key := range want.Header {
		gotHeader[key] = req.Header.Values(key)
	}
	if !reflect.DeepEqual(gotHeader, want.Header) {
		return fmt.Errorf("Header: got (%#v), want (%#v)", gotHeader, want.Header)
	}

	if len(want.Body) == 0 {
		return nil
	}

	gotBody, _ := ioutil.ReadAll(req.Body)
	gotContentType := req.Header.Get("Content-Type")
	if strings.HasPrefix(gotContentType, "application/json") {
		// Remove the trailing newline from the JSON bytes encoded by Go.
		// See https://github.com/golang/go/issues/37083.
		gotBody = bytes.TrimSuffix(gotBody, []byte("\n"))
	}

	if !bytes.Equal(gotBody, want.Body) {
		return fmt.Errorf("Body: got (%q), want (%q)", gotBody, want.Body)
	}

	return nil
}

type ClientResponse struct {
	StatusCode int
	Header 	   http.Header
	Body       []byte
}

func (resp ClientResponse) HTTPResponse() *http.Response {
	statusCode := resp.StatusCode
	if statusCode == 0 {
		statusCode = http.StatusOK
	}

	return &http.Response{
		StatusCode: statusCode,
		Header:     resp.Header,
		Body:       io.NopCloser(bytes.NewReader(resp.Body)),
	}
}

{{- range $.Spec.Tests}}

{{$method := interfaceMethod .Name}}
{{$params := $method.Params}}
{{$ctxParam := ctxParam $params}}
{{$nonCtxParams := nonCtxParams $params}}

func TestHTTPClient_{{.Name}}(t *testing.T) {
	// in contains all the input parameters (except ctx) of {{.Name}}.
	type in struct {
		{{- if $ctxParam}}
		{{title $ctxParam.Name}} {{$ctxParam.TypeString}}
		{{- end}}
		{{- range $nonCtxParams}}
		{{title .Name}} {{.TypeString}} ` + "`httptest:\"{{.Name}}\"`" + `
		{{- end}}
	}

	// out contains all the output parameters of {{.Name}}.
	type out struct {
		{{- range $method.Returns}}
		{{title .Name}} {{.TypeString}} ` + "`httptest:\"{{.Name}}\"`" + `
		{{- end}}
	}

	tests := []struct {
		name        string
		in          map[string]interface{}
		wantRequest ClientRequest
		response    ClientResponse
		wantOut     map[string]interface{}
	}{
		{{- range .Subtests}}
		{
			name: "{{.Name}}",
			in: {{goString .In}},
			wantRequest: ClientRequest{
				Method: "{{.WantRequest.Method}}",
				Path:   "{{.WantRequest.Path}}",
				{{- if .WantRequest.Header}}
				header: {{goString .WantRequest.Header}},
				{{- end}}
				{{- if .WantRequest.Body}}
				Body: {{bodyToBytes .WantRequest.Body}},
				{{- end}}
			},
			response: ClientResponse{
				StatusCode: {{.Response.StatusCode}},
				{{- if .Response.Header}}
				Header: {{goString .Response.Header}},
				{{- end}}
				{{- if .Response.Body}}
				Body: {{bodyToBytes .Response.Body}},
				{{- end}}
			},
			wantOut: {{goString .WantOut}},
		},
		{{- end}}
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var gotRequest *http.Request
			httpClient := NewTestHTTPClient(func(req *http.Request) (*http.Response, error) {
				gotRequest = req
				return tt.response.HTTPResponse(), nil
			})
			sut, err := {{$.Spec.Client}}(httpClient, "http://localhost:8080")
			if err != nil {
				t.Errorf("err when creating Client: %v", err)
			}

			var in in
			if err := serverCodec.Decode(tt.in, &in); err != nil {
				t.Errorf("err when decoding In: %v", err)
			}
			{{- if $ctxParam}}
			in.{{title $ctxParam.Name}} = context.Background()
			{{- end}}

			var gotOut out
			{{fmtArgCSV $method.ReturnArgValueList "gotOut.>Name"}} = sut.{{.Name}}({{fmtArgCSV $method.CallArgList "in.>Name"}})

			if err := tt.wantRequest.Equal(gotRequest); err != nil {
				t.Error(err.Error())
			}

			encodedGotOut, err := clientCodec.Encode(gotOut)
			if err != nil {
				t.Errorf("err when encoding gotOut: %v", err)
			}

			// Using "%+v" instead of "%#v" as a workaround for https://github.com/go-yaml/yaml/issues/139.
			if fmt.Sprintf("%+v", encodedGotOut) != fmt.Sprintf("%+v", tt.wantOut) {
				t.Errorf("Out: Got (%+v) != Want (%+v)", encodedGotOut, tt.wantOut)
			}
		})
	}
}
{{- end}}
`
)
