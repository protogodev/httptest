// Code generated by httptest; DO NOT EDIT.
// github.com/protogodev/httptest

package usersvc_test

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"reflect"
	"strings"
	"testing"
	"time"

	"github.com/RussellLuo/structool"
	"github.com/protogodev/httptest/examples/usersvc"
)

var serverCodec = structool.New().TagName("httptest").
	DecodeHook(
		structool.DecodeStringToError,
		structool.DecodeStringToTime(time.RFC3339),
		structool.DecodeStringToDuration,
	).
	EncodeHook(
		structool.EncodeErrorToString,
		structool.EncodeTimeToString(time.RFC3339),
		structool.EncodeDurationToString,
	)

// Ensure that ServiceMock does implement usersvc.Service.
var _ usersvc.Service = &ServiceMock{}

type ServiceMock struct {
	CreateUserFunc func(ctx context.Context, user *usersvc.User) (err error)
	DeleteUserFunc func(ctx context.Context, name string) (err error)
	GetUserFunc    func(ctx context.Context, name string) (user *usersvc.User, err error)
	ListUsersFunc  func(ctx context.Context) (users []*usersvc.User, err error)
	UpdateUserFunc func(ctx context.Context, name string, user *usersvc.User) (err error)
}

func (mock *ServiceMock) CreateUser(ctx context.Context, user *usersvc.User) (err error) {
	if mock.CreateUserFunc == nil {
		panic("ServiceMock.CreateUserFunc: not implemented")
	}
	return mock.CreateUserFunc(ctx, user)
}

func (mock *ServiceMock) DeleteUser(ctx context.Context, name string) (err error) {
	if mock.DeleteUserFunc == nil {
		panic("ServiceMock.DeleteUserFunc: not implemented")
	}
	return mock.DeleteUserFunc(ctx, name)
}

func (mock *ServiceMock) GetUser(ctx context.Context, name string) (user *usersvc.User, err error) {
	if mock.GetUserFunc == nil {
		panic("ServiceMock.GetUserFunc: not implemented")
	}
	return mock.GetUserFunc(ctx, name)
}

func (mock *ServiceMock) ListUsers(ctx context.Context) (users []*usersvc.User, err error) {
	if mock.ListUsersFunc == nil {
		panic("ServiceMock.ListUsersFunc: not implemented")
	}
	return mock.ListUsersFunc(ctx)
}

func (mock *ServiceMock) UpdateUser(ctx context.Context, name string, user *usersvc.User) (err error) {
	if mock.UpdateUserFunc == nil {
		panic("ServiceMock.UpdateUserFunc: not implemented")
	}
	return mock.UpdateUserFunc(ctx, name, user)
}

type ServerRequest struct {
	Method string
	Path   string
	Header http.Header
	Body   []byte
}

func (r ServerRequest) ServedBy(handler http.Handler) *http.Response {
	req := httptest.NewRequest(r.Method, r.Path, nil)
	if len(r.Body) > 0 {
		req = httptest.NewRequest(r.Method, r.Path, bytes.NewReader(r.Body))
		req.Header.Set("Content-Type", "application/json; charset=utf-8")
	}

	for key, values := range r.Header {
		for _, v := range values {
			req.Header.Add(key, v)
		}
	}

	w := httptest.NewRecorder()
	handler.ServeHTTP(w, req)

	return w.Result()
}

type ServerResponse struct {
	StatusCode int
	Header     http.Header
	Body       []byte
}

func (want ServerResponse) Equal(resp *http.Response) error {
	gotStatusCode := resp.StatusCode
	if gotStatusCode != want.StatusCode {
		return fmt.Errorf("StatusCode: got (%d), want (%d)", gotStatusCode, want.StatusCode)
	}

	if gotStatusCode == http.StatusNoContent {
		return nil
	}

	var gotHeader http.Header
	if len(want.Header) > 0 {
		gotHeader = http.Header{}
	}
	for key := range want.Header {
		gotHeader[key] = resp.Header.Values(key)
	}
	if !reflect.DeepEqual(gotHeader, want.Header) {
		return fmt.Errorf("Header: got (%#v), want (%#v)", gotHeader, want.Header)
	}

	gotBody, _ := ioutil.ReadAll(resp.Body)
	gotContentType := resp.Header.Get("Content-Type")
	if strings.HasPrefix(gotContentType, "application/json") {
		// Remove the trailing newline from the JSON bytes encoded by Go.
		// See https://github.com/golang/go/issues/37083.
		gotBody = bytes.TrimSuffix(gotBody, []byte("\n"))
	}

	if !bytes.Equal(gotBody, want.Body) {
		return fmt.Errorf("Body: got (%q), want (%q)", gotBody, want.Body)
	}

	return nil
}

func TestHTTPServer_GetUser(t *testing.T) {
	// in contains all the input parameters (except ctx) of GetUser.
	type in struct {
		Name string `httptest:"name"`
	}

	// out contains all the output parameters of GetUser.
	type out struct {
		User *usersvc.User `httptest:"user"`
		Err  error         `httptest:"err"`
	}

	tests := []struct {
		name         string
		request      ServerRequest
		wantIn       map[string]interface{}
		out          map[string]interface{}
		wantResponse ServerResponse
	}{
		{
			name: "ok",
			request: ServerRequest{
				Method: "GET",
				Path:   "/users/foo",
			},
			wantIn: map[string]interface{}{"name": "foo"},
			out:    map[string]interface{}{"err": "", "user": map[interface{}]interface{}{"birth": "2022-01-01T00:00:00Z", "name": "foo", "sex": "male"}},
			wantResponse: ServerResponse{
				StatusCode: 200,
				Body:       []byte(`{"name":"foo","sex":"male","birth":"2022-01-01T00:00:00Z"}`),
			},
		},
		{
			name: "err",
			request: ServerRequest{
				Method: "GET",
				Path:   "/users/foo",
			},
			wantIn: map[string]interface{}{"name": "foo"},
			out:    map[string]interface{}{"err": "not found", "user": interface{}(nil)},
			wantResponse: ServerResponse{
				StatusCode: 400,
				Body:       []byte(`{"error":"not found"}`),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			newServer := usersvc.NewHTTPServer

			var out out
			if err := serverCodec.Decode(tt.out, &out); err != nil {
				t.Errorf("err when decoding Out: %v", err)
			}

			var gotIn in
			resp := tt.request.ServedBy(newServer(&ServiceMock{
				GetUserFunc: func(ctx context.Context, name string) (user *usersvc.User, err error) {
					gotIn = in{
						Name: name,
					}
					return out.User, out.Err
				},
			}))

			encodedGotIn, err := serverCodec.Encode(gotIn)
			if err != nil {
				t.Errorf("err when encoding gotIn: %v", err)
			}

			// Using "%+v" instead of "%#v" as a workaround for https://github.com/go-yaml/yaml/issues/139.
			if fmt.Sprintf("%+v", encodedGotIn) != fmt.Sprintf("%+v", tt.wantIn) {
				t.Errorf("In: Got (%+v) != Want (%+v)", encodedGotIn, tt.wantIn)
			}

			if err := tt.wantResponse.Equal(resp); err != nil {
				t.Error(err.Error())
			}
		})
	}
}

func TestHTTPServer_ListUsers(t *testing.T) {
	// in contains all the input parameters (except ctx) of ListUsers.
	type in struct {
	}

	// out contains all the output parameters of ListUsers.
	type out struct {
		Users []*usersvc.User `httptest:"users"`
		Err   error           `httptest:"err"`
	}

	tests := []struct {
		name         string
		request      ServerRequest
		wantIn       map[string]interface{}
		out          map[string]interface{}
		wantResponse ServerResponse
	}{
		{
			name: "ok",
			request: ServerRequest{
				Method: "GET",
				Path:   "/users",
			},
			wantIn: map[string]interface{}(nil),
			out:    map[string]interface{}{"err": "", "users": []interface{}{map[interface{}]interface{}{"birth": "2022-01-01T00:00:00Z", "name": "foo", "sex": "male"}}},
			wantResponse: ServerResponse{
				StatusCode: 200,
				Body:       []byte(`{"users":[{"name":"foo","sex":"male","birth":"2022-01-01T00:00:00Z"}]}`),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			newServer := usersvc.NewHTTPServer

			var out out
			if err := serverCodec.Decode(tt.out, &out); err != nil {
				t.Errorf("err when decoding Out: %v", err)
			}

			var gotIn in
			resp := tt.request.ServedBy(newServer(&ServiceMock{
				ListUsersFunc: func(ctx context.Context) (users []*usersvc.User, err error) {
					gotIn = in{}
					return out.Users, out.Err
				},
			}))

			encodedGotIn, err := serverCodec.Encode(gotIn)
			if err != nil {
				t.Errorf("err when encoding gotIn: %v", err)
			}

			// Using "%+v" instead of "%#v" as a workaround for https://github.com/go-yaml/yaml/issues/139.
			if fmt.Sprintf("%+v", encodedGotIn) != fmt.Sprintf("%+v", tt.wantIn) {
				t.Errorf("In: Got (%+v) != Want (%+v)", encodedGotIn, tt.wantIn)
			}

			if err := tt.wantResponse.Equal(resp); err != nil {
				t.Error(err.Error())
			}
		})
	}
}

func TestHTTPServer_CreateUser(t *testing.T) {
	// in contains all the input parameters (except ctx) of CreateUser.
	type in struct {
		User *usersvc.User `httptest:"user"`
	}

	// out contains all the output parameters of CreateUser.
	type out struct {
		Err error `httptest:"err"`
	}

	tests := []struct {
		name         string
		request      ServerRequest
		wantIn       map[string]interface{}
		out          map[string]interface{}
		wantResponse ServerResponse
	}{
		{
			name: "ok",
			request: ServerRequest{
				Method: "POST",
				Path:   "/users",
				Body:   []byte(`{"name":"foo","sex":"male","birth":"2022-01-01T00:00:00Z"}`),
			},
			wantIn: map[string]interface{}{"user": map[interface{}]interface{}{"birth": "2022-01-01T00:00:00Z", "name": "foo", "sex": "male"}},
			out:    map[string]interface{}{"err": ""},
			wantResponse: ServerResponse{
				StatusCode: 204,
			},
		},
		{
			name: "err",
			request: ServerRequest{
				Method: "POST",
				Path:   "/users",
				Body:   []byte(`{"name":"foo","sex":"male","birth":"2022-01-01T00:00:00Z"}`),
			},
			wantIn: map[string]interface{}{"user": map[interface{}]interface{}{"birth": "2022-01-01T00:00:00Z", "name": "foo", "sex": "male"}},
			out:    map[string]interface{}{"err": "already exists"},
			wantResponse: ServerResponse{
				StatusCode: 400,
				Body:       []byte(`{"error":"already exists"}`),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			newServer := usersvc.NewHTTPServer

			var out out
			if err := serverCodec.Decode(tt.out, &out); err != nil {
				t.Errorf("err when decoding Out: %v", err)
			}

			var gotIn in
			resp := tt.request.ServedBy(newServer(&ServiceMock{
				CreateUserFunc: func(ctx context.Context, user *usersvc.User) (err error) {
					gotIn = in{
						User: user,
					}
					return out.Err
				},
			}))

			encodedGotIn, err := serverCodec.Encode(gotIn)
			if err != nil {
				t.Errorf("err when encoding gotIn: %v", err)
			}

			// Using "%+v" instead of "%#v" as a workaround for https://github.com/go-yaml/yaml/issues/139.
			if fmt.Sprintf("%+v", encodedGotIn) != fmt.Sprintf("%+v", tt.wantIn) {
				t.Errorf("In: Got (%+v) != Want (%+v)", encodedGotIn, tt.wantIn)
			}

			if err := tt.wantResponse.Equal(resp); err != nil {
				t.Error(err.Error())
			}
		})
	}
}

func TestHTTPServer_UpdateUser(t *testing.T) {
	// in contains all the input parameters (except ctx) of UpdateUser.
	type in struct {
		Name string        `httptest:"name"`
		User *usersvc.User `httptest:"user"`
	}

	// out contains all the output parameters of UpdateUser.
	type out struct {
		Err error `httptest:"err"`
	}

	tests := []struct {
		name         string
		request      ServerRequest
		wantIn       map[string]interface{}
		out          map[string]interface{}
		wantResponse ServerResponse
	}{
		{
			name: "ok",
			request: ServerRequest{
				Method: "PATCH",
				Path:   "/users/foo",
				Body:   []byte(`{"sex":"male","birth":"2022-01-01T00:00:00Z"}`),
			},
			wantIn: map[string]interface{}{"name": "foo", "user": map[interface{}]interface{}{"birth": "2022-01-01T00:00:00Z", "sex": "male"}},
			out:    map[string]interface{}{"err": ""},
			wantResponse: ServerResponse{
				StatusCode: 204,
			},
		},
		{
			name: "err",
			request: ServerRequest{
				Method: "PATCH",
				Path:   "/users/foo",
				Body:   []byte(`{"sex":"male","birth":"2022-01-01T00:00:00Z"}`),
			},
			wantIn: map[string]interface{}{"name": "foo", "user": map[interface{}]interface{}{"birth": "2022-01-01T00:00:00Z", "sex": "male"}},
			out:    map[string]interface{}{"err": "not found"},
			wantResponse: ServerResponse{
				StatusCode: 400,
				Body:       []byte(`{"error":"not found"}`),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			newServer := usersvc.NewHTTPServer

			var out out
			if err := serverCodec.Decode(tt.out, &out); err != nil {
				t.Errorf("err when decoding Out: %v", err)
			}

			var gotIn in
			resp := tt.request.ServedBy(newServer(&ServiceMock{
				UpdateUserFunc: func(ctx context.Context, name string, user *usersvc.User) (err error) {
					gotIn = in{
						Name: name,
						User: user,
					}
					return out.Err
				},
			}))

			encodedGotIn, err := serverCodec.Encode(gotIn)
			if err != nil {
				t.Errorf("err when encoding gotIn: %v", err)
			}

			// Using "%+v" instead of "%#v" as a workaround for https://github.com/go-yaml/yaml/issues/139.
			if fmt.Sprintf("%+v", encodedGotIn) != fmt.Sprintf("%+v", tt.wantIn) {
				t.Errorf("In: Got (%+v) != Want (%+v)", encodedGotIn, tt.wantIn)
			}

			if err := tt.wantResponse.Equal(resp); err != nil {
				t.Error(err.Error())
			}
		})
	}
}

func TestHTTPServer_DeleteUser(t *testing.T) {
	// in contains all the input parameters (except ctx) of DeleteUser.
	type in struct {
		Name string `httptest:"name"`
	}

	// out contains all the output parameters of DeleteUser.
	type out struct {
		Err error `httptest:"err"`
	}

	tests := []struct {
		name         string
		request      ServerRequest
		wantIn       map[string]interface{}
		out          map[string]interface{}
		wantResponse ServerResponse
	}{
		{
			name: "ok",
			request: ServerRequest{
				Method: "DELETE",
				Path:   "/users/foo",
			},
			wantIn: map[string]interface{}{"name": "foo"},
			out:    map[string]interface{}{"err": ""},
			wantResponse: ServerResponse{
				StatusCode: 204,
			},
		},
		{
			name: "err",
			request: ServerRequest{
				Method: "DELETE",
				Path:   "/users/foo",
			},
			wantIn: map[string]interface{}{"name": "foo"},
			out:    map[string]interface{}{"err": "not found"},
			wantResponse: ServerResponse{
				StatusCode: 400,
				Body:       []byte(`{"error":"not found"}`),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			newServer := usersvc.NewHTTPServer

			var out out
			if err := serverCodec.Decode(tt.out, &out); err != nil {
				t.Errorf("err when decoding Out: %v", err)
			}

			var gotIn in
			resp := tt.request.ServedBy(newServer(&ServiceMock{
				DeleteUserFunc: func(ctx context.Context, name string) (err error) {
					gotIn = in{
						Name: name,
					}
					return out.Err
				},
			}))

			encodedGotIn, err := serverCodec.Encode(gotIn)
			if err != nil {
				t.Errorf("err when encoding gotIn: %v", err)
			}

			// Using "%+v" instead of "%#v" as a workaround for https://github.com/go-yaml/yaml/issues/139.
			if fmt.Sprintf("%+v", encodedGotIn) != fmt.Sprintf("%+v", tt.wantIn) {
				t.Errorf("In: Got (%+v) != Want (%+v)", encodedGotIn, tt.wantIn)
			}

			if err := tt.wantResponse.Equal(resp); err != nil {
				t.Error(err.Error())
			}
		})
	}
}
